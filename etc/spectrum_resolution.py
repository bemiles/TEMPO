"""
Created on Sun Jun 22 17:16:27 2025

@author: ellabutler

This script reads in spectral models and computes the 
spectral resolution as a function of wavelength. It is designed for use with 
models stored locally, specifically those generated by the PHOENIX/BT-Settl 
grid. Given filenames (or optionally, parameters like temperature, 
surface gravity, and metallicity), the code loads the spectra, extracts the 
wavelength and flux data, computes the spectral resolution (R = λ / Δλ), 
and returns it for further analysis or plotting. Users can visualize 
the resolution or rebin/interpolate it to compare with observational 
requirements.

Spectra are expected to be in ASCII format with a header of 2 lines and 
two columns: wavelength (microns) and flux (erg/cm²/s/Hz).
"""

import os
import io
import xarray
import tarfile
import numpy as np
# pip install picaso
# pip install expecto
import matplotlib.pyplot as plt
from scipy.interpolate import interp1d


def get_filepath(filename, base_dir="/Users/ellabutler/MilesGroup/5063476"):
    """
    Load spectrum data from within a .tar.gz archive.

    Parameters
    ----------
    filename : str
        Base filename (without .tar.gz extension)

    Returns
    -------
    wavelength : ndarray
        Wavelength array in microns
    flux : ndarray
        Flux array in erg/cm²/s/Hz
    """
    filepath = os.path.join(base_dir, filename + ".tar.gz")
    return filepath


def load_bobcat_spectrum_from_tar(filename, teff, grav, mh):
    """
    Load Sonora Bobcat spectrum data from within a .tar.gz file.

    Parameters
    ----------
    filename : str
        Base file name (without .tar.gz extension)
        
    teff: int
        Effective temperature in Kelvin
        
    grav: int
        Surface gravity in MKS units 
        
    mh: int
        Metallicity 
        

    Returns
    -------
    wavelength : ndarray
        Wavelength array in microns
    flux : ndarray
        Flux array in erg/cm²/s/Hz
    """
    filepath = get_filepath(filename)
    with tarfile.open(filepath, mode='r:gz') as tar:
        # Get the first file in the archive
        member = tar.getmembers()[0]
        f = tar.extractfile(member)
        if f is None:
            raise IOError(f"Could not extract file from {filepath}")
        content = f.read().decode("utf-8")
        data = np.genfromtxt(io.StringIO(content), skip_header=2)
    
    wavelength = data[:, 0]  # wavelength in microns
    flux = data[:, 1]        # flux in erg/cm^2/s/Hz
    return wavelength, flux

def load_diamondback_spectrum_from_tar(filename, teff, grav, mh, co, logkzz):
    """
    Load Sonora Diamondback spectrum data from within a .tar.gz file.

    Parameters
    ----------
    filename : str
        Base filename (without .tar.gz extension)
            
    teff: int
        Effective temperature in Kelvin
        
    grav: int
        Surface gravity in MKS units 
        
    mh: int
        Metallicity 
        
    co: int
        Carbon/Oxygen ratio related to solar abundance
        
    logkzz: int
        log of the eddy diffusion coefficient 
        

    Returns
    -------
    wavelength : ndarray
        Wavelength array in microns
    flux : ndarray
        Flux array in erg/cm²/s/Hz
    """
    filepath = get_filepath(filename)
    with tarfile.open(filepath, mode='r:gz') as tar:
        # Get the first file in the archive
        member = tar.getmembers()[0]
        f = tar.extractfile(member)
        if f is None:
            raise IOError(f"Could not extract file from {filepath}")
        content = f.read().decode("utf-8")
        data = np.genfromtxt(io.StringIO(content), skip_header=2)
    
    wavelength = data[:, 0]  # wavelength in microns
    flux = data[:, 1]        # flux in erg/cm^2/s/Hz
    return wavelength, flux
    
    
def load_elfowl_spectrum_from_tar(filename, teff, grav, mh, co, logkzz):
    """
    Load Sonora Elf Owl spectrum data from within a .tar.gz file.

    Parameters
    ----------
    filename : str
        Base filename (without .tar.gz extension)
            
    teff: int
        Effective temperature in Kelvin
        
    grav: int
        Surface gravity in MKS units 
        
    mh: int
        Metallicity 
        
    co: int
        Carbon/Oxygen ratio related to solar abundance
        
    logkzz: int
        log of the eddy diffusion coefficient 
        

    Returns
    -------
    wavelength : ndarray
        Wavelength array in microns
    flux : ndarray
        Flux array in erg/cm²/s/Hz
    """
    teff= '450.0' #K
    grav='31.0' # m/s/s
    mh='-1.0'
    co='0.5' # relative to solar
    logkzz='9.0' 
    ds = xarray.load_dataset(f'/filename/output_425.0_475.0/spectra_logzz_{logkzz}_teff_{teff}_grav_{grav}_mh_{mh}_co_{co}.nc')
    return ds
    

def compute_resolution(wavelength):
    """
    Compute the spectral resolution- R = λ / Δλ.

    Parameters
    ----------
    wavelength : ndarray
        Wavelength array in microns

    Returns
    -------
    resolution : ndarray
        Spectral resolution array (one element shorter than input)  
    """
    delta_lambda = np.diff(wavelength)
    resolution = wavelength[1:] / delta_lambda
    return resolution


def get_model_filename(temperature, gravity, metallicity):
    """
    Generate the model filename based on input parameters. Works only for 
    Sonora Bobcat and Diamondback files

    Parameters
    ----------
    temperature : int
        Stellar effective temperature (e.g., 200 for 2000 K)
    gravity : float
        log10(surface gravity in cgs, i.e. log(g/cm/s²))
    metallicity : float
        Metallicity [M/H] (e.g., -0.5, +0.5)

    Returns
    -------
    filename : str
        Model filename string
    """
    g_str = f"g{int(gravity * 10)}"
    m_sign = "+" if metallicity > 0 else "-" if metallicity < 0 else "0.0"
    m_str = f"m{m_sign}{metallicity}"
    model_filename = f"sp_t{temperature}{g_str}nc_{m_str}"
    return model_filename


def plot_resolution(wavelength, resolution, label=None):
    """
    Plot spectral resolution as a function of wavelength.

    Parameters
    ----------
    wavelength : ndarray
        Original wavelength array (includes the first point not used in resolution).

    resolution : ndarray
        Computed resolution values (length = len(wavelength) - 1).

    label : str, optional
        Legend label for the plot.
    
    Returns
    -------
    None
    """
    plt.plot(wavelength[1:], resolution, label=label)
    plt.xlabel('Wavelength (microns)')
    plt.ylabel('Resolution (λ / Δλ)')
    plt.title("Spectral Resolution vs. Wavelength")
    plt.xlim(1.0, 14.0)
    plt.ylim(0, np.nanmax(resolution) * 1.1)
    if label:
        plt.legend()
    plt.grid(True)


def rebin_spectrum_to_resolution(wavelength, flux, target_resolution):
    """
    Rebin a spectrum to a constant desired resolution R = λ / Δλ using
    linear spacing.

    Parameters
    ----------
    wavelength : ndarray
        Original wavelength array in microns 
        (must be sorted in ascending order).
    flux : ndarray
        Original flux array (same length as wavelength).
    target_resolution : float
        Desired constant spectral resolution.

    Returns
    -------
    rebinned_wavelength : ndarray
        Array of rebinned wavelength centers.
    rebinned_flux : ndarray
        Array of rebinned fluxes interpolated to those centers.
    """
    sort_idx = np.argsort(wavelength)
    wavelength = wavelength[sort_idx]
    flux = flux[sort_idx]

    start = wavelength[0]
    end = wavelength[-1]

    rebinned_wavelength = []
    rebinned_flux = []

    current_lambda = start
    flux_interp = interp1d(wavelength, flux, kind='linear', bounds_error=False, 
                                                      fill_value="extrapolate")

    while current_lambda < end:
        delta_lambda = current_lambda / target_resolution
        next_lambda = current_lambda + delta_lambda
        bin_center = (current_lambda + next_lambda) / 2
        bin_flux = flux_interp(bin_center)

        rebinned_wavelength.append(bin_center)
        rebinned_flux.append(bin_flux)

        current_lambda = next_lambda

    return np.array(rebinned_wavelength), np.array(rebinned_flux)

# add a function for Madden files - pull in cloudy Earth model + 
# clear Earth model

# add input for host star spectral type 

# perform stress testing 

    
# co ratios range from 0.5, 1, 1.5 

# write as a Jupyter notebook too! 


# make it so that the user can plug in a temperature, surface gravity, and 
# metallicity, to get back the inputs requested 

# add a user input for resolution and mode (wavelength min and max is fixed)

# add user input for kzz and co for elf owl function 



# later down the line: fix the hardcoded file path so it can also take a Madden
# file

# document the different integers for the available models

# add documentation for each line

# try expecto (PHOENIX stellar spectra) 

# try pulling in TEMPO observing modes txt file (not the imaging section)
